defmodule ArangoXEcto do
  @moduledoc """
  Ecto adapter for ArangoDB using ArangoX
  """

  @otp_app :arangox_ecto

  @behaviour Ecto.Adapter
  @behaviour Ecto.Adapter.Schema
  @behaviour Ecto.Adapter.Queryable
  @behaviour Ecto.Adapter.Storage

  @impl Ecto.Adapter
  defmacro __before_compile__(_env) do
    # Maybe something later
  end

  use Bitwise, only_operators: true

  alias ArangoXEcto.Storage

  @doc """
  Starts the Agent with an empty list
  """
  def start_link({_module, config}) do
    log_message(:debug, "#{inspect(__MODULE__)}.start_link", %{
      "#{inspect(__MODULE__)}.start_link-params" => %{config: config}
    })

    Agent.start_link(fn -> [] end)
  end

  @doc """
  Initialise adapter with `config`
  """
  @impl Ecto.Adapter
  def init(config) do
    child = Arangox.child_spec(config)

    # Maybe something here later
    meta = %{}

    {:ok, child, meta}
  end

  @doc """
  Ensure all applications necessary to run the adapter are started
  """
  @impl Ecto.Adapter
  def ensure_all_started(config, type) do
    log_message(:debug, "#{inspect(__MODULE__)}.ensute_all_started", %{
      "#{inspect(__MODULE__)}.ensure_all_started-params" => %{type: type, config: config}
    })

    with {:ok, _} = Application.ensure_all_started(@otp_app) do
      {:ok, [config]}
    end
  end

  @doc """
  Delegate storage functions to storage module.

  Creates, deletes and checks status of database
  """
  defdelegate storage_up(options), to: Storage
  defdelegate storage_status(options), to: Storage
  defdelegate storage_down(options), to: Storage

  @doc """
  Checks out a connection for the duration of the given function.
  """
  @impl Ecto.Adapter
  def checkout(_meta, _opts, _fun) do
    raise "#{inspect(__MODULE__)}.checkout: #{inspect(__MODULE__)} does not currently support checkout"
  end

  @doc """
  Streams a previously prepared query.
  """
  @impl Ecto.Adapter.Queryable
  def stream(_adapter_meta, _query_meta, _query, _params, _options) do
    raise "#{inspect(__MODULE__)}.stream: #{inspect(__MODULE__)} does not currently support stream"
  end

  @doc """
  Called to autogenerate a value for id/embed_id/binary_id.

  Returns nil since we want to use an id generated by arangodb
  """
  @impl Ecto.Adapter.Schema
  def autogenerate(:id), do: raise("ArangoDB does not support type :id")
  def autogenerate(:embed_id), do: Ecto.UUID.generate()
  def autogenerate(:binary_id), do: nil

  @doc """
  Returns the loaders of a given type.
  """
  @impl Ecto.Adapter
  def loaders(:uuid, Ecto.UUID), do: [&{:ok, &1}]
  def loaders(:date, _type), do: [&load_date/1]
  def loaders(:time, _type), do: [&load_time/1]
  def loaders(:utc_datetime, _type), do: [&load_utc_datetime/1]
  def loaders(:naive_datetime, _type), do: [&NaiveDateTime.from_iso8601/1]
  def loaders(:float, _type), do: [&load_float/1]
  def loaders(_primitive, type), do: [type]

  @doc """
  Returns the dumpers for a given type.
  """
  @impl Ecto.Adapter
  def dumpers(:uuid, Ecto.UUID), do: [&{:ok, &1}]
  def dumpers({:in, sub}, {:in, sub}), do: [{:array, sub}]

  def dumpers(:date, type) when type in [:date, Date],
    do: [fn %Date{} = d -> {:ok, Date.to_iso8601(d)} end]

  def dumpers(:time, type) when type in [:time, Time],
    do: [fn %Time{} = t -> {:ok, Time.to_iso8601(t)} end]

  def dumpers(:utc_datetime, type) when type in [:utc_datetime, DateTime],
    do: [fn %DateTime{} = dt -> {:ok, DateTime.to_iso8601(dt)} end]

  def dumpers(:naive_datetime, type) when type in [:naive_datetime, NaiveDateTime],
    do: [fn %NaiveDateTime{} = dt -> {:ok, NaiveDateTime.to_iso8601(dt)} end]

  def dumpers(_primitive, type), do: [type]

  @doc """
  Commands invoked to prepare a query.
  It is used on Ecto.Repo.all/2, Ecto.Repo.update_all/3, and Ecto.Repo.delete_all/2.
  """
  @impl Ecto.Adapter.Queryable
  def prepare(cmd, query) do
    log_message(:debug, "#{inspect(__MODULE__)}.prepare: #{cmd}", %{
      "#{inspect(__MODULE__)}.prepare-params" => %{auery: inspect(query, structs: false)}
    })

    IO.inspect(query)

    aql_query = apply(ArangoXEcto.Query, cmd, [query])
    {:nocache, aql_query}
  end

  @doc """
  Executes a previously prepared query.
  """
  @impl Ecto.Adapter.Queryable
  def execute(
        %{pid: conn},
        %{sources: {{collection, _, _}}, select: selecting},
        {:nocache, query},
        params,
        _options
      ) do
    log_message(:debug, "#{inspect(__MODULE__)}.execute", %{
      "#{inspect(__MODULE__)}.execute-params" => %{query: inspect(query, structs: false)}
    })

    options = if selecting == nil, do: [], else: [write: collection]

    zipped_args =
      Stream.zip(Stream.iterate(1, &(&1 + 1)) |> Stream.map(&Integer.to_string(&1)), params)
      |> Enum.into(%{})

    res =
      Arangox.transaction(
        conn,
        fn cursor ->
          stream = Arangox.cursor(cursor, query, zipped_args)

          Enum.reduce(stream, [], fn resp, acc ->
            acc ++ resp.body["result"]
          end)
        end,
        options
      )

    case res do
      {:ok, result} -> {length(result), result}
      {:error, _reason} -> {0, nil}
    end
  end

  @doc """
  Inserts a single new struct in the data store.
  """
  @impl Ecto.Adapter.Schema
  def insert(
        %{pid: conn},
        %{source: collection},
        fields,
        _on_conflict,
        returning,
        _options
      ) do
    doc = Enum.into(fields, %{})

    log_message(:debug, "#{inspect(__MODULE__)}.insert", %{
      "#{inspect(__MODULE__)}.insert-params" => %{document: inspect(doc)}
    })

    return_new = Enum.any?(returning, &(not (&1 in [:_id, :_key, :_rev])))
    options = if return_new, do: "?returnNew=true", else: ""

    Arangox.post(
      conn,
      "/_api/document/#{collection}" <> options,
      doc
    )
    |> IO.inspect()
    |> single_doc_result(returning, return_new)
  end

  @doc """
  Inserts multiple entries into the data store.
  """
  @impl Ecto.Adapter.Schema
  def insert_all(
        %{pid: conn},
        %{source: collection},
        _header,
        list,
        _on_conflict,
        returning,
        _options
      ) do
    #    IO.inspect(list)
    #    IO.inspect(returning)

    docs = build_docs(list)
    return_new = not Enum.any?(returning, &(not (&1 in [:_id, :_key, :_rev])))
    options = if return_new, do: "?returnNew=true", else: ""

    case Arangox.post(
           conn,
           "/_api/document/#{collection}" <> options,
           docs
         ) do
      {:ok, _, %{body: body}} ->
        get_insert_fields(body, returning, return_new)

      {:error, %{status: status}} ->
        {:invalid, status}
    end
  end

  @doc """
  Deletes a single struct with the given filters.
  """
  @impl Ecto.Adapter.Schema
  def delete(%{pid: conn}, %{source: collection}, [{:_key, key}], _options) do
    case Arangox.delete(conn, "/_api/document/#{collection}/#{key}") do
      {:ok, _, _} -> {:ok, []}
      {:error, %{status: status}} -> {:error, status}
    end
  end

  def delete(_adapter_meta, _schema_meta, _filters, _options) do
    # TODO: Do this
    raise "Deleting with filters other than _key is not supported yet"
  end

  @doc """
  Updates a single struct with the given filters.
  """
  @impl Ecto.Adapter.Schema
  def update(%{pid: conn}, %{source: collection}, fields, [{:_key, key}], returning, _options) do
    document = Enum.into(fields, %{})

    return_new = not Enum.any?(returning, &(not (&1 in [:_id, :_key, :_rev])))
    options = if return_new, do: "?returnNew=true", else: ""

    Arangox.patch(
      conn,
      "/_api/document/#{collection}/#{key}" <> options,
      document
    )
    |> single_doc_result(returning, return_new)
  end

  def update(_adapter_meta, _schema_meta, _fields, _filters, _returning, _options) do
    # TODO: Do this
    raise "Updating with filters other than _key is not supported yet"
  end

  @doc """
  Logs message to console. Log levels, colours, etc. set in config
  """
  def log_message(level, msg, attrs \\ %{}, opts \\ []) do
    log_levels = Application.get_env(@otp_app, :log_levels) || [:info]

    if level in log_levels do
      depth = opts[:depth] || 4
      colours = Application.get_env(@otp_app, :log_colours)
      date = DateTime.utc_now()

      formatted_msg =
        "#{date.year}-#{date.month}-#{date.day} #{date.hour}:#{date.minute}:#{date.second} UTC [Ecto ArangoDB #{
          level
        }] #{msg}"

      {:ok, log_message} =
        Jason.encode(%{message: formatted_msg, attributes: readable(attrs, depth)})

      if Application.get_env(@otp_app, :log_in_colour) do
        IO.puts(IO.ANSI.format([colours[level] || :normal, log_message], true))
      else
        IO.puts(log_message)
      end
    end
  end

  defp readable(str, _depth) when is_binary(str), do: str
  defp readable(num, _depth) when is_number(num), do: num
  defp readable(any, _depth) when not is_map(any) and not is_list(any), do: inspect(any)
  defp readable(_, 0), do: "beyond_log_depth"
  defp readable(%{__struct__: _} = struct, _depth), do: inspect(struct)

  defp readable(map, depth) when is_map(map) do
    for {k, v} <- map, into: %{}, do: {k, readable(v, depth - 1)}
  end

  defp readable(list, depth) when is_list(list) do
    for item <- list, do: readable(item, depth - 1)
  end

  defp build_docs(fields) when is_list(fields) do
    Enum.map(fields, fn
      %{} = doc -> doc
      doc when is_list(doc) -> Enum.into(doc, %{})
    end)
  end

  defp single_doc_result({:ok, _, %Arangox.Response{body: %{"new" => doc}}}, returning, true) do
    {:ok, Enum.map(returning, &{&1, Map.get(doc, Atom.to_string(&1))})}
  end

  defp single_doc_result({:ok, _, %Arangox.Response{body: doc}}, returning, false) do
    doc = patch_body_keys(doc)
    {:ok, Enum.map(returning, &{&1, Map.get(doc, Atom.to_string(&1))})}
  end

  defp single_doc_result({:error, %{error_num: 1210, message: msg}}, _, _) do
    {:invalid, [unique: msg]}
  end

  defp single_doc_result({:error, %{error_num: error_num, message: msg}}, _, _) do
    raise "#{inspect(__MODULE__)} Error(#{error_num}): #{msg}"
  end

  defp replacement_key(key) do
    replacements = %{"1" => "_key", "2" => "_rev", "3" => "_id"}

    case Map.get(replacements, to_string(key)) do
      nil -> key
      k -> k
    end
  end

  defp patch_body_keys(%{} = body) do
    for {k, v} <- body, into: %{}, do: {replacement_key(k), v}
  end

  defp get_insert_fields(docs, returning, false), do: process_docs(docs, returning)

  defp get_insert_fields(docs, returning, true) do
    process_docs(Enum.map(docs, & &1["new"]), returning)
  end

  defp process_docs(docs, []), do: {length(docs), nil}

  defp process_docs(docs, _returning) do
    # TODO: Possibly broken
    {length(docs), docs}
  end

  #  defp validate_struct(module, %{} = params),
  #    do: module.changeset(struct(module.__struct__), params)

  defp load_date(d) do
    case Date.from_iso8601(d) do
      {:ok, res} -> {:ok, res}
      {:error, _reason} -> :error
    end
  end

  defp load_time(t) do
    case Time.from_iso8601(t) do
      {:ok, res} -> {:ok, res}
      {:error, _reason} -> :error
    end
  end

  defp load_utc_datetime(dt) do
    case DateTime.from_iso8601(dt) do
      {:ok, res, _} -> {:ok, res}
      {:error, _reason} -> :error
    end
  end

  def load_float(arg) when is_number(arg), do: {:ok, :erlang.float(arg)}
  def load_float(_), do: :error
end
